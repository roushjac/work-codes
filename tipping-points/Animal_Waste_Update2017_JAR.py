
# This script generates rasters of Nitrogen and Phosphorus in kg/yr from Animal Manure for the Great Lakes Basin. 
# It requires many inputs, most of which come from the associated R script. Many parts of this script were copied over 
# and edited from a script originally written to do the same thing in Michigan only. This script is located at 
# S:\Users\lusczemi\Source Files\Animals\AnimalWasteModel

# Written by Jake Roush on 6/30/17
import arcpy
import os, subprocess
import pandas as pd, numpy as np
import time
import threading

#%% Convert CSVs from R outputs into dbf files
# This was not working with 64 bit background processing enabled and I cannot figure out how to to fix it. Doing it manually 
# in ArcMap for now
arcpy.TableToTable_conversion('S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\All_CAFOs_Final.xlsx\Sheet1$', 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs', 'All_CAFOs_Final')
arcpy.TableToTable_conversion('S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Confined_Animals.xlsx', 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs', 'Confined_Animals')
arcpy.TableToTable_conversion('S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Manure_Acres_and_Operations.xlsx', 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs', 'Manure_Acres_and_Operations')
arcpy.TableToTable_conversion('S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Pasture_Animals.xlsx', 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs', 'Pasture_Animals')
arcpy.TableToTable_conversion('S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Total_Confined_County_Loads.xlsx', 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs', 'Total_Confined_County_Loads')


#%% Refresh inputs cell

#Set working directory for the script - separate from the ArcPy working directory
os.chdir("S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python")


#Output path
outDir = 'D:\\Arc_Data\\ManureOutputs.gdb'
scratchWork = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Outputs\\scratchGDB.gdb'
#Set the workspace
arcpy.env.workspace = outDir
arcpy.env.scratchWorkspace = scratchWork

#Check out a Spatial Analyst license
arcpy.CheckOutExtension('Spatial')

#-------------------------------------------------------------------------------
#Inputs
#-------------------------------------------------------------------------------

#Model boundary, buffered
featureBdry = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\GLB_Counties_Albers_No_Great_Lakes.shp'
#Basin Model Counties: This is a shapefile of GLB basin counties with county ID's
featureCounties = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\GLB_Counties_Albers_No_Great_Lakes.shp'
#Total County Confined Manure: This table is exported from the R script, called "total confined county loads"
tableManureTotal= 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\Total_Confined_County_Loads.dbf'
tableAllCAFOs= 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\All_CAFOs_Final.dbf'
fieldManureCtyN = 'kgN/year'
fieldManureCtyP = 'kgP/year'
featureBasinCAFOsOrig = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\CAFO_GLB_States_Only.shp'
featureBasinCAFOs = 'All_CAFOs_Albers'
#Total Manure Application Area: This table is exported from the R script, called "manure acres and operations"
tableManureArea = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\Manure_Acres_and_Operations.dbf'
#Number of Farms per County
tableFarmCountsCon ='S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\Confined_Animals.dbf'
tableFarmCountsPast ='S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\Pasture_Animals.dbf'
#tableLoads = 'S:\\Users\\lusczemi\\Source Files\\Animals\\AnimalWasteModel\\CON_LOAD.dbf'
##tableLoadsPas = 'F:\\Users\\Lusczemi\\Source Files\\Animals\\Animal Waste Model\\PAS_LOAD.dbf'
fieldNLoad = 'kgN_farm_y' # This is a rate per farm per year. Each BIN_CTY has a unique rate
fieldPLoad = 'kgP_farm_y' # This is a rate per farm per year. Each BIN_CTY has a unique rate
fieldNUnrecovered = 'kgN_y_urec'
fieldPUnrecovered = 'kgP_y_urec'
fieldAnimalBin = 'GMEID'
fieldLoadID = 'BIN_CTY'
fieldFarmCount = 'FARMS_TOT'
#Fertilizer Demand
# As of initially writing this script on 6-30-2017, these rasters were made using the old model method. They will work for
# now, but should be updated to use rasters generated by the new model
rasterNFertilizerDemand ='S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\ManureCDLandNLCD.gdb\\CDL_N_20082015_Model_GLB'
rasterPFertilizerDemand ='S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\ManureCDLandNLCD.gdb\\CDL_P_20082015_Model_GLB'
#2006 NLCD
rasterNLCD  = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\ManureCDLandNLCD.gdb\\NLCD_albers_counties'
rasterNLCDRect = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\ManureCDLandNLCD.gdb\\NLCD_GLB_Rec_Alb_ND255_AGMASK'
#Golf Courses
featureGolfCourses = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Inputs\\ManureCDLandNLCD.gdb\\GLB_golf_courses'
# File path to scratch GDB for conversion to pandas dataframe since CalculateField is stubborn in its quest to thwart me
scratchFilePath = "S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Outputs\\scratchGDB.gdb"
# File path to a map document containing the GLB counties in Albers - used to reference the spatial reference of the dataframe
mapFilePath = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\GIS\\GLB_Counties_Albers.mxd'
# Spatial reference of the GLB counties shapefile
spatialRefGLB = arcpy.Describe(featureCounties).spatialReference
#-------------------------------------------------------------------------------
#Outputs
#-------------------------------------------------------------------------------
#CAFO Polys for use in Commercial Ag model
outCAFOArea = outDir+'\\CAFO_Manure_Influence_Area'
#Final Outputs
outNMan = 'NMankg'
outPMan ='PMankg'


#-------------------------------------------------------------------------------
#Parameters
#-------------------------------------------------------------------------------
#Set Parameters: This can vary
cellSize = 30
ReqAreaThreshold = .05 # 5 percent - means that the difference in area needs to be below 5%
ConvThreshold = .04 #Percentage of CAFOS whose area needs to converge before loop ends
paramFocalDist = 667 #Approximately 20km radius
paramFocalDistPasture = 15 #Approximately 40 acres circular area
paramPastureAssimiliation = .0084

#Temporary Parameters: Don't need to change these
featureTempGolfCourses = 'tempGolfCourses'
rasterGolfCourses = 'D:\\Arc_Data\\ManureOutputs.gdb\\Golf_Courses'
fieldRaster = 'raster'
fieldCountyJoin = 'CtyID'
fieldManureAreaTotal = 'MAN_M2'
featureTempCountyManure = 'CtyMan'
rasterFocalArea = 'FocalArea'
rasterFocalAreaPast = 'FocalAreaPast'
featureTempCountyManureArea = 'CtyManArea'
featureTempCountyManureClip = 'CtyManClip'
fieldAvgRate = 'AvgR'
featureCAFOLocationPolys = 'DNRE_CAFO_Polys'
rasterRequiredArea = 'Required_Area'
rasterRequiredAreaPast = 'Required_Area_Past'
featureExclusionArea = 'LoopExcluded_AgArea'
featureExclusionAreaCounties = 'LoopExcluded_AgArea_Counties'
featureExclusionAreaCountiesDiss = 'LoopExcluded_AgArea_Counties_Diss'
featureTempConfinedHerds = 'Confined_Herds'
featureTempConfinedFarms = 'ConfinedFarms'
featurePointSourceFarms = 'PointSourceFarms'
featureTempAllFertilzedCells = 'All_Fert_Cells'
featureTempAllFertilzedCellsRect = 'All_Fert_Cells_Rect'
featureTempCAFOFertilizedCells = 'All_Fert_Cells_with_CAFOs'
featureTempCAFOFertilizedCellsNoPast = 'All_Fert_Cells_with_CAFOs_no_Past'
tableManureClip = "S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Outputs\\scratchGDB.gdb"
pathCalcGDB = "S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Outputs\\scratchGDB.gdb"
tempCSVfile = 'S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\Outputs\\tempCSV.csv'
CurrentBin = 'Current'
fieldInitialRadius = 'RInit'
fieldAreaDiff = 'ADiff'
fieldNewRadius = 'RNew'
featureWasteBuffers = 'Waste_Buff_New'
featureWasteBuffersClip = 'Waste_Buff_Clip'
featureWasteBuffersClipPast = 'Waste_Buff_Clip_Past'
featureWasteBuffersPreDissolved = 'Waste_Buff_PreDiss'
featureWasteBuffersDissolved = 'Waste_Buff_Diss'
featureWasteBuffersClipArea = 'Waste_Buff_Clip_Area'
featureWasteBuffersClipAreaPast = 'Waste_Buff_Clip_Area_Pasture'
fieldAreaRequired = 'Req_Area'
fieldClipArea = 'F_AREA'
fieldFIDUnGrouped = 'FID_'+featureTempConfinedFarms
fieldFIDGroup = 'Near_FID'
fieldFIDFarm = 'ObjectID'
tableGroupedBuffers = 'Grouped_Buffer_Stats'
fieldAreaReqTotal = 'SUM_'+fieldAreaRequired
fieldNLoadSum = 'SUM_'+fieldNLoad
fieldPLoadSum = 'SUM_'+fieldPLoad
ProblemFarms = 'Problem_Farms'
BuffersNotConverged = 'NotConverged'
rasterNWasteSupply = 'Waste_SuppyN'
rasterPWasteSupply = 'Waste_SupplyP'
rasterNFertilizerNormDemand = 'Waste_Demand_NormN'
rasterPFertilizerNormDemand = 'Waste_Demand_NormP'
rasterNConfUnrec = 'NUnrecovered'
rasterPConfUnrec = 'PUnrecovered'
rasterNPointSourceFarms = 'NPointSourceFarms'
rasterPPointSourceFarms = 'PPointSourceFarms'
featureNLCDPasture = 'NLCD_Pasture'
featurePastureCells = 'NLCD_Pasture_Areas'
featurePastureCounties = 'County_Pasture_Areas'
featurePastureGME = 'GME_Pasture_Polys'
featurePastureHerds = 'Pasture_Herds'
rasterNPastureRate = 'NPastureRate'
rasterPPastureRate = 'PPastureRate'
rasterNPasture = 'NPasture'
rasterPPasture = 'PPasture'
pointSourceBinCounties = () # Making a tuple of all bin_cty values that we are treating as point sources due to lack of area
#-------------------------------------------------------------------------------
#Set environment parameters
#-------------------------------------------------------------------------------
#Set the extent, projection, and cellsize
##cellSize=arcpy.GetRasterProperties_management(featureBdry,'CELLSIZEX')

# Putting in entire path because the .Describe() function was not working properly with only the variable name
extent = arcpy.Describe(rasterNLCD).extent
extentL = extent.XMin
extentR = extent.XMax
extentT = extent.YMax
extentB = extent.YMin
extentString = str(extentL)+' '+str(extentB)+' '+str(extentR)+' '+str(extentT)

arcpy.env.cellSize = cellSize
arcpy.env.snapRaster = rasterNLCD
arcpy.env.extent = extentString
arcpy.env.outputCoordinateSystem = featureBdry
arcpy.env.overwriteOutput = True
arcpy.env.outputZFlag = "Disabled"
arcpy.env.outputMFlag = "Disabled"

#-------------------------------------------------------------------------------
#Writing functions to be used as inputs to subprocess() for GME
# Subprocess needs to be written into functions in order to successfully use threading - using these 
def RunEnterKey():
    subprocess.call(['python','PressEnterKeyboard.py'])
    
def RunGMEConf_NoExcl():
    subprocess.Popen("C:\\Program Files (x86)\\SpatialEcology\\GME\\SEGME.exe -c run(in=\\\"S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\GMEAnimalWasteConfined_NoExclusion.txt\\\");").wait()
#    subprocess.call(['python','RunGMEConfined_No_Exclusion.py']) #Old way of doing this where I call a different python script

def RunGMEConf_Excl():
    subprocess.Popen("C:\\Program Files (x86)\\SpatialEcology\\GME\\SEGME.exe -c run(in=\\\"S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\GMEAnimalWasteConfined.txt\\\");").wait()
#    subprocess.call(['python','RunGMEConfined.py'])

def RunGMEPast_NoExcl():
    subprocess.Popen("C:\\Program Files (x86)\\SpatialEcology\\GME\\SEGME.exe -c run(in=\\\"S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\GMEAnimalWastePasture_NoExclusion.txt\\\");").wait()

def RunGMEPast_Excl():
    subprocess.Popen("C:\\Program Files (x86)\\SpatialEcology\\GME\\SEGME.exe -c run(in=\\\"S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python\\GMEAnimalWastePasture.txt\\\");").wait()


#def dissolveInSubprocess(in_fc, out_fc, dissolve_fields = '#', stat_fields = '#', multi_part = 'MULTI_PART', unsplit_lines = "DISSOLVE_LINES", xytol = '#'):
#    """Execute dissolve tool in a subprocess"""
#    opts = (in_fc, out_fc, dissolve_fields, stat_fields, multi_part, unsplit_lines, xytol)
#    cmd = r"C:\Python27\ArcGIS10.2\python.exe S:\Users\roushjac\Python\Useful Scripts\dissolver.py " + " ".join(map(str, opts))
#    print "Executing subprocess with " + str(cmd)
#    chld = subprocess.Popen(cmd, stdout=subprocess.PIPE)
#    r = chld.communicate()
#    print r
#    if chld.returncode != 0:
#        raise Exception("Error while dissolving in subprocess:" + str(chld.returncode))
#    else:
#        print "Finished subprocess with " + str(cmd)
#    return chld.returncode

def dissolveInSubprocess():
    # No longer useful. Was using this as a potential workaround to dissolve_management running out of memory
#    cmd = r"C:\Python27\ArcGIS10.2\python.exe S:\Users\roushjac\Python\Useful Scripts\Dissolver.py"
#    subprocess.Popen(cmd).wait()
    subprocess.call(['C:\Python27\ArcGIS10.2\python.exe','Dissolver_for_farms.py'])

#%%

#-------------------------------------------------------------------------------
# Do the processing
#-------------------------------------------------------------------------------

#Convert CDL to Null Fertilization Raster (1=feritilizable cell,0=notfertilizable), Remove Golf Courses, Use NLCD 2006 to remove Urban/Barren Categories

#Convert Golf Courses to Raster
arcpy.CopyFeatures_management(featureGolfCourses,featureTempGolfCourses)
# Don't think that arcpy.da.TableToNumPyArray can have fields of Null values - think I can remove the AddField and make it in the dataframe
#arcpy.AddField_management(featureTempGolfCourses,fieldRaster)
#arcpy.CalculateField_management(featureTempGolfCourses,fieldRaster,1,'PYTHON_9.3')

# This chunk is replacing CalculateField
arcpy.MakeTableView_management(featureTempGolfCourses, "GolfCourseTableView")
arcpy.TableToTable_conversion("GolfCourseTableView", scratchFilePath, "GolfCourseTable")
tempArray = arcpy.da.TableToNumPyArray(scratchFilePath+'\\GolfCourseTable', ['*'])
dfGolfCourse = pd.DataFrame(tempArray)
arcpy.Delete_management(scratchFilePath+'\\GolfCourseTable')
del tempArray
dfGolfCourse[fieldRaster] = 1 # This creates the field, then populates it - removes the need for AddField on the initial table
dfGolfCourse.to_csv(tempCSVfile,index=False)
arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempGolfCourseTable')
#arcpy.DeleteField_management(featureTempGolfCourses, ['raster']) # Getting rid of NA fields so that they may be added in the join
arcpy.JoinField_management(featureTempGolfCourses,'OBJECTID','tempGolfCourseTable','OBJECTID', [fieldRaster])
arcpy.Delete_management('tempGolfCourseTable')

arcpy.PolygonToRaster_conversion(featureTempGolfCourses,fieldRaster,rasterGolfCourses)

#Next use NLCD and CDL to select Ag Cells
inRasterCDLN = arcpy.Raster(rasterNFertilizerDemand)
inRasterCDLP = arcpy.Raster(rasterPFertilizerDemand)
inRasterNLCD = arcpy.Raster(rasterNLCD)
inRasterGolf = arcpy.Raster(rasterGolfCourses)
inRasterBasinRect = arcpy.Raster(rasterNLCDRect)
conNLCD = arcpy.sa.Con((inRasterNLCD > 70) & (inRasterNLCD < 90),1,0)
conNLCD1 = arcpy.sa.Con(arcpy.sa.IsNull(conNLCD),0,conNLCD)
RectMinusBasin = (inRasterBasinRect - conNLCD1)
conCDL_N = arcpy.sa.Con(inRasterCDLN==0,0,1)
conCDL_N1 = arcpy.sa.Con(arcpy.sa.IsNull(conCDL_N),0,conCDL_N)
conCDL_P = arcpy.sa.Con(inRasterCDLP==0,0,1)
conCDL_P1 = arcpy.sa.Con(arcpy.sa.IsNull(conCDL_P),0,conCDL_P)
nullGolf = arcpy.sa.IsNull(inRasterGolf)
conGolf = arcpy.sa.Con(nullGolf,1,0)
# Making rectangle layer
maskCDLRect = ((conCDL_N1+conCDL_P1)*conNLCD1*conGolf)+RectMinusBasin
maskCDL2Rect = arcpy.sa.Con(maskCDLRect==0,0,1)
maskCDL3Rect = arcpy.sa.SetNull(maskCDL2Rect==0,1)
arcpy.RasterToPolygon_conversion(maskCDL3Rect, featureTempAllFertilzedCellsRect)
# Now making basin-only layer
maskCDLBasin = (conCDL_N1+conCDL_P1)*conNLCD1*conGolf
maskCDL2Basin = arcpy.sa.Con(maskCDLBasin==0,0,1)
maskCDL3Basin = arcpy.sa.SetNull(maskCDL2Basin==0,1)
arcpy.RasterToPolygon_conversion(maskCDL3Basin, featureTempAllFertilzedCells)

#Run Focal Stats on CDL
# Since we are allowing buffers to spread further into the US than the basin,
# FocalStatistics needs to be run on the total area we will be spreading manure
# on. This is a different layer than the layer used to place down farms.
start = time.ctime()
startsec = time.time()
neighborhood = arcpy.sa.NbrCircle(paramFocalDist,'CELL')
FocalStats = arcpy.sa.FocalStatistics(maskCDL3Rect,neighborhood,'SUM','DATA')
#Calculate Neighborhood Fertilizer Area Raster
FocalArea = FocalStats*cellSize**2
FocalArea.save(rasterFocalArea)
end = time.ctime()
endsec = time.time()
print 'Start: '+start
print 'End: '+end
print 'FocalStats took '+str((endsec - startsec)/60)+' minutes!'

# Clipping focal stats raster to only be in the basin


#Housekeeping!!
arcpy.Delete_management(featureTempGolfCourses,rasterGolfCourses)

#Associate Manure Totals/Area with Counties
arcpy.CopyFeatures_management(featureCounties,featureTempCountyManure)
arcpy.JoinField_management(featureTempCountyManure, fieldCountyJoin, tableManureArea, fieldCountyJoin, ['Man_m2'])
arcpy.JoinField_management(featureTempCountyManure, fieldCountyJoin, tableManureTotal, fieldCountyJoin, ['kgP_year','kgN_year'])
#Estimate County Average Application Rates for Manure Collected from Confined Animals. This rate will be used to calculate the 
# initial radii of buffers later in this script
#arcpy.AddField_management(featureTempCountyManure,fieldAvgRate,'FLOAT')
#arcpy.CalculateField_management(featureTempCountyManure,fieldAvgRate,'!'+fieldManureCtyP+'!/!'+fieldManureAreaTotal+'!','PYTHON_9.3')

## For rates that are above 
arcpy.MakeTableView_management(featureTempCountyManure, "CountyManureTableView")
arcpy.TableToTable_conversion("CountyManureTableView", scratchFilePath, "CountyManureTable")
tempArray = arcpy.da.TableToNumPyArray(scratchFilePath+'\\CountyManureTable', ['*'])
dfCountyManure = pd.DataFrame(tempArray)
arcpy.Delete_management(scratchFilePath+'\\CountyManureTable')
del tempArray
dfCountyManure[fieldAvgRate] =  dfCountyManure['kgP_year'] / dfCountyManure['Man_m2'] # This creates the field, then populates it - removes the need for AddField on the initial table
dfCountyManure['AvgRHect'] = dfCountyManure['AvgR']*10000
dfCountyManure['AvgRfromN'] = dfCountyManure['kgN_year'] / dfCountyManure['Man_m2']
dfCountyManure.loc[dfCountyManure['AvgR'] > dfCountyManure.quantile(.9, axis = 0)['AvgR'], 'AvgR'] = dfCountyManure.quantile(.9, axis = 0)['AvgR']
dfCountyManure.to_csv(tempCSVfile,index=False)
arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempManureCountyTable')
arcpy.JoinField_management(featureTempCountyManure,fieldCountyJoin,'tempManureCountyTable',fieldCountyJoin, ['AvgR'])
arcpy.Delete_management('tempManureCountyTable')
arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity

#%% Plotting histogram of AvgR values in hectares to visualize if county loads are reasonable
dfCountyManure['AvgRHect'] = dfCountyManure['AvgR']*10000

avgrhist = dfCountyManure['AvgRHect'].plot.hist(bins=100)
avgrmedian = dfCountyManure.median()

# Finding counties that are above 400 kgP/hect/year so that we can look at why they are so high
HighCounties = dfCountyManure.loc[dfCountyManure['AvgRHect'] > 1000]
#%%


# Copying the manure counties to preserve the AvgR field - featureTempCountyManure is getting clipped and modified, 
# would lose the significance of the AvgR field
arcpy.CopyFeatures_management(featureTempCountyManure,featureTempCountyManureArea)

#Clip County Data by Ag Cells and dissolve by County
arcpy.Clip_analysis(featureTempCountyManure,featureTempAllFertilzedCells,featureTempCountyManureClip)
arcpy.Dissolve_management(featureTempCountyManureClip,featureTempCountyManure,fieldCountyJoin,'','MULTI_PART')
#arcpy.AddField_management(featureTempCountyManure,fieldInitialRadius,'FLOAT')
#arcpy.AddField_management(featureTempCountyManure,fieldAreaRequired,'FLOAT')

# Adding AvgR back into manure layer for use in calculating intial radii/areas required
arcpy.JoinField_management(featureTempCountyManure, fieldCountyJoin, featureTempCountyManureArea, fieldCountyJoin, fieldAvgRate)

arcpy.CopyFeatures_management(featureTempCountyManure,featureTempCountyManureClip)
# Making a "clean" version of the manure clipped counties for easy resetting after each iteration of the loop
arcpy.CopyFeatures_management(featureTempCountyManureClip,featureTempCountyManureClip+'clean')

#%%
###Make CAFO Locations part of Ag Area
# First converting lat/long coordinates from CAFO table into a new point layer
## as of 9/13/17, the MakeXYEventLayer function in arcpy does not seem to be working with Arc version 10.2.2.
## Instead of spending more time strugging I am going to manually do it in Arc, which works fine.
## Remember to clip out CAFO points that are outside of the basin, as these have coordinates that were
## entered incorrectly.

# Did manually in ArcMap because projections are difficult to script in here

#arcpy.MakeXYEventLayer_management(table="S:/Users/roushjac/Tipping Points/Manure/Script/Python/Inputs/All_CAFOs_Final.dbf",in_x_field="Longitude",in_y_field="Latitude",out_layer="All_CAFOs_Final_Layer",spatial_reference="GEOGCS['GCS_WGS_1984',DATUM['D_WGS_1984',SPHEROID['WGS_1984',6378137.0,298.257223563]],PRIMEM['Greenwich',0.0],UNIT['Degree',0.0174532925199433]];-400 -400 1000000000;-100000 10000;-100000 10000;8.98315284119522E-09;0.001;0.001;IsHighPrecision",in_z_field="#")
#arcpy.FeatureClassToFeatureClass_conversion(in_features="All_CAFOs_Final_Layer",out_path="S:/Users/roushjac/Tipping Points/Manure/Script/Python/Outputs/ManureOutputs.gdb",out_name="All_CAFOs_Final_Feature",where_clause="#",field_mapping="""F1 "F1" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,F1,-1,-1;Census_Spe "Census_Spe" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,Census_Spe,-1,-1;CAFO_Speci "CAFO_Speci" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,CAFO_Speci,-1,-1;CTYID "CTYID" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,CTYID,-1,-1;Bin "Bin" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,Bin,-1,-1;State "State" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,State,-1,-1;County "County" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,County,-1,-1;Physical_L "Physical_L" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,Physical_L,-1,-1;Zipcode "Zipcode" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,Zipcode,-1,-1;City "City" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,City,-1,-1;Operation "Operation" true true false 254 Text 0 0 ,First,#,All_CAFOs_Final_Layer,Operation,-1,-1;Latitude "Latitude" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,Latitude,-1,-1;Longitude "Longitude" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,Longitude,-1,-1;Animal_Num "Animal_Num" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,Animal_Num,-1,-1;OcFraction "OcFraction" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,OcFraction,-1,-1;AvgOfN__as "AvgOfN__as" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,AvgOfN__as,-1,-1;AvgOfP__as "AvgOfP__as" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,AvgOfP__as,-1,-1;Recoverabi "Recoverabi" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,Recoverabi,-1,-1;kgN_y_rec "kgN_y_rec" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,kgN_y_rec,-1,-1;kgP_y_rec "kgP_y_rec" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,kgP_y_rec,-1,-1;kgN_y_urec "kgN_y_urec" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,kgN_y_urec,-1,-1;kgP_y_urec "kgP_y_urec" true true false 16 Double 6 15 ,First,#,All_CAFOs_Final_Layer,kgP_y_urec,-1,-1""",config_keyword="#")
#arcpy.CopyFeatures_management("All_CAFOs_Final_Layer", outDir+'/'+"All_CAFOs_Final_Feature")

# Creating copy of CAFO layer and converting into a feature layer in case I need to reset it


# Creating layer of Ag cells in basin rectangle
arcpy.Buffer_analysis(featureBasinCAFOs, featureCAFOLocationPolys,10,'','ROUND','NONE')
arcpy.Merge_management([featureTempAllFertilzedCellsRect,featureCAFOLocationPolys],featureTempCAFOFertilizedCells)



#Determine Maximum Bin
arcpy.Statistics_analysis(tableFarmCountsCon,'tableBinMax',[[fieldAnimalBin,'MAX'],['Correcte_1','SUM']])
rows=arcpy.SearchCursor('tableBinMax')
for row in rows:
    binIDmax=row.getValue('MAX_GMEID')
    TotalEstAnimals=row.getValue('SUM_Correcte_1')

#%%
#loop Through Each Bin type and distribute to available cells based on availability of Ag Cells near by.
#This loop opens up GME five times per iteration. It also uses a workaround to get around a pesky error window opening with GME.
#Make sure that you have the correct version of Arc installed to run GME;as of 7/3/2017, GME cannot run on versions of Arc past 10.3.
start = time.ctime()
startsec = time.time()
for binID in range(1,int(binIDmax+1)):
    startlooptime = time.time()
    arcpy.MakeTableView_management(tableFarmCountsCon,CurrentBin,fieldAnimalBin+'='+str(binID))
    time.sleep(2)
    arcpy.JoinField_management(featureTempCountyManureClip,fieldCountyJoin,CurrentBin,fieldCountyJoin)
    # Removing Null rows
    up_curs = arcpy.UpdateCursor(featureTempCountyManureClip, "BIN_CTY IS NULL")
    for row in up_curs:
        if not row.getValue('BIN_CTY'):
            up_curs.deleteRow(row)

    del up_curs
    arcpy.MakeTableView_management(featureTempCountyManureClip, "ManureClipTableView")
    arcpy.TableToTable_conversion("ManureClipTableView", tableManureClip, "ManureClipTable")
    tempArray = arcpy.da.TableToNumPyArray(tableManureClip+'/ManureClipTable', ['*'])
    dfManureClip = pd.DataFrame(tempArray)
    arcpy.Delete_management(tableManureClip+'/ManureClipTable')
    del tempArray
    dfManureClip['RInit'] = (pd.to_numeric(dfManureClip['kgP_farm_y']) / (dfManureClip['AvgR'] * (22/7)))**0.5
    dfManureClip['Req_Area'] = (22/7) * dfManureClip['RInit'] * dfManureClip['RInit']
    dfManureClip.to_csv(tempCSVfile,index=False)
    arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempManureClipTable')
    arcpy.DeleteField_management(featureTempCountyManureClip, ['RInit','Req_Area']) # Getting rid of NA Radius and Area fields, so that they may be added in the join
    arcpy.JoinField_management(featureTempCountyManureClip,fieldCountyJoin,'tempManureClipTable',fieldCountyJoin, ['RInit', 'Req_Area'])
    arcpy.Delete_management('tempManureClipTable') # Deleting temporary table
    arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
    arcpy.PolygonToRaster_conversion(featureTempCountyManureClip,fieldAreaRequired,rasterRequiredArea)
    inRasterRequiredArea = arcpy.Raster(rasterRequiredArea)
    inRasterFocalArea = arcpy.Raster(rasterFocalArea)
    conRequiredArea = arcpy.sa.Con((inRasterRequiredArea>inRasterFocalArea),1,0)
    ExclusionResult = arcpy.GetRasterProperties_management(conRequiredArea,'MAXIMUM') # Gives memory errors if scratch workspace is not cleared frequently
    ExclusionResultMax = ExclusionResult.getOutput(0)
    if int(ExclusionResultMax) == 0:
        for fifthmult in range(0,5): # Choosing 1 to 5 because we are splitting up GME into 5 parts. Has 225 counties - 45 counties each part
            mult = 45*fifthmult
#            arcpy.SelectLayerByAttribute_management('Near_Buffers','NEW_SELECTION',' "NEAR_DIST" = 0')
            arcpy.MakeFeatureLayer_management(featureTempCountyManureClip,'CtyManClipOneFifth')
            arcpy.SelectLayerByAttribute_management('CtyManClipOneFifth', 'NEW_SELECTION', ' "OBJECTID" >= '+str(1+mult)+' AND "OBJECTID" <= '+str(45+mult))
            arcpy.CopyFeatures_management('CtyManClipOneFifth', 'CtyManClipOneFifthGME')
            # Error window popping up in GME is preventing loop from continuing. Can't figure out how to stop it,
            # so using this unnecessarily convoluted method to get around it.
            # Using threading to start GME, then run a separate Python script that presses the "enter" key after 5 seconds
            os.chdir("S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python")
            thread1 = threading.Thread(target=RunGMEConf_NoExcl)
            thread2 = threading.Thread(target=RunEnterKey)
            thread1.start()
            thread2.start()
            thread1.join() # Stops python until thread closes, signaling the finish of GME
    else:
        nullRequiredArea = arcpy.sa.SetNull(conRequiredArea==0,1)
        arcpy.RasterToPolygon_conversion(nullRequiredArea,featureExclusionArea) #This resets the python working directory!!! Need to reassign it
        os.chdir("S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python")
        # Some counties do not have any usable Ag cells after looking at excluded area - for these counties, ignore exclusion area
        # and place farms down anyway. These farms need to be treated as point sources!
        arcpy.SpatialJoin_analysis(featureExclusionArea, featureCounties, featureExclusionAreaCounties,'JOIN_ONE_TO_MANY','','','INTERSECT')
        arcpy.Dissolve_management(featureExclusionAreaCounties, featureExclusionAreaCountiesDiss, fieldCountyJoin,'','MULTI_PART')
#        arcpy.JoinField_management(featureExclusionAreaCountiesDiss, fieldCountyJoin, featureTempCountyManureClip, fieldCountyJoin, ['Req_Area'])
        arcpy.RasterToPolygon_conversion(conRequiredArea, 'RequiredAreaPolygon', 'SIMPLIFY','Value')
        arcpy.SpatialJoin_analysis('RequiredAreaPolygon', featureCounties, 'RequiredAreaPolygonCounties','JOIN_ONE_TO_MANY','','','INTERSECT')
        arcpy.Dissolve_management('RequiredAreaPolygonCounties', 'RequiredAreaPolygonCounties_Diss', fieldCountyJoin,'gridcode MIN','MULTI_PART') 
        # Dissolves counties together, but also finds the minimum 'gridcode' value for the county. A min of 1 means that every available Ag cell in the county is excluded.
#        arcpy.Statistics_analysis('RequiredAreaPolygonCounties_Diss', 'tableRequiredArea_Stats', ['value', 'MIN'], [fieldCountyJoin])
        arcpy.JoinField_management(featureExclusionAreaCountiesDiss, fieldCountyJoin, 'RequiredAreaPolygonCounties_Diss', fieldCountyJoin)
        up_curs = arcpy.UpdateCursor(featureExclusionAreaCountiesDiss, "MIN_gridcode = 1")
        for row in up_curs:
            if int(row.getValue('MIN_gridcode')) == 1:
                pointSourceBinCounties = (str(binID)+str(row.getValue(fieldCountyJoin)),)+pointSourceBinCounties
                up_curs.deleteRow(row)

        del up_curs
        arcpy.CopyFeatures_management(featureExclusionAreaCountiesDiss, featureExclusionArea)
        for fifthmult in range(0,5): # Choosing 1 to 5 because we are splitting up GME into 5 parts. Has 225 counties - 45 counties each part
            mult = 45*fifthmult
#           arcpy.SelectLayerByAttribute_management('Near_Buffers','NEW_SELECTION',' "NEAR_DIST" = 0')
            arcpy.MakeFeatureLayer_management(featureTempCountyManureClip,'CtyManClipOneFifth')
            arcpy.SelectLayerByAttribute_management('CtyManClipOneFifth', 'NEW_SELECTION', ' "OBJECTID" >= '+str(1+mult)+' AND "OBJECTID" <= '+str(45+mult))
            arcpy.CopyFeatures_management('CtyManClipOneFifth', 'CtyManClipOneFifthGME')
            os.chdir("S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python")
            thread1 = threading.Thread(target=RunGMEConf_Excl)
            thread2 = threading.Thread(target=RunEnterKey)
            thread1.start()
            thread2.start()
            thread1.join() # Stops python until thread closes, signaling the finish of GME
        del(nullRequiredArea)
        arcpy.Delete_management(featureExclusionArea)
        arcpy.Delete_management(featureExclusionAreaCounties)
        arcpy.Delete_management(featureExclusionAreaCountiesDiss)
        
    print 'The bin is:',binID
    endlooptime = time.time()
    print 'This loop took '+str(endlooptime - startlooptime)+' seconds, '+str((endlooptime - startlooptime)/60.)+' minutes, or '+str((endlooptime - startlooptime)/3600.)+' hours.'
    arcpy.CopyFeatures_management(featureTempCountyManureClip+'clean',featureTempCountyManureClip)
    del(inRasterRequiredArea, inRasterFocalArea, conRequiredArea)

end = time.ctime()
endsec = time.time()
pointSourceBinCountiesFinal = pointSourceBinCounties
print 'Start: '+start
print 'End: '+end
print 'Total time was '+str(endsec - startsec)+' seconds, '+str((endsec - startsec)/60)+' minutes, or '+str((endsec - startsec)/3600)+' hours!'

#%% Deleting extra points that were generated as a result of using 'operations' instead of 'corrected operations'
#arcpy.MakeFeatureLayer_management(featureTempConfinedHerds, 'testConfinedHerds')
#search_curs = arcpy.SearchCursor(tableFarmCountsCon)
#for row in search_curs:
#    oneBinCty = row.getValue('BIN_CTY')
#    corrOps = row.getValue('Correcte_1')
#    arcpy.SelectLayerByAttribute_management('testConfinedHerds', 'NEW_SELECTION', '"BIN_CTY" = \''+str(oneBinCty)+'\' AND "PNTID" > '+str(int(corrOps)))
#    arcpy.DeleteFeatures_management('testConfinedHerds')
#    arcpy.SelectLayerByAttribute_management('testConfinedHerds', 'CLEAR_SELECTION')
#
#del search_curs
#arcpy.CopyFeatures_management('testConfinedHerds','testConfined_Herds')


#%%

# Housekeeping
arcpy.DeleteField_management(featureTempConfinedHerds,['PNTID'])

# Join randomly placed farms to counties, with rate info
arcpy.SpatialJoin_analysis(featureTempConfinedHerds,featureTempCountyManureArea,featureTempConfinedFarms,'JOIN_ONE_TO_MANY','','','INTERSECT')

#Join Loading Rates to Points based on bin/animal type and county. These fields have rates in kg/farm/year
arcpy.JoinField_management(featureTempConfinedFarms,fieldLoadID,tableFarmCountsCon,fieldLoadID,['kgP_y_rec','kgN_y_rec','kgP_y_urec','kgN_y_urec','kgP_farm_y','kgN_farm_y'] )

# Join CAFO points to AvgR info from each county
arcpy.JoinField_management(featureBasinCAFOs, 'CTYID', featureTempCountyManureArea, 'CTYID', [fieldAvgRate])

# Copying random farms to make sure they don't get messed up when I reassign them
arcpy.CopyFeatures_management(featureTempConfinedFarms, featureTempConfinedFarms+'clean')
# Joining CAFO points to randomly placed points. Need to make sure that the info
# on bin_cty rates are kept during the join

# As of 10/4/17, this merge is outputting only the ConfinedFarms - I think the CAFO layer is corrupted! Should try to remake it
# Problem solved on 10/6/17. Be careful about projections - make sure to keep them the same between both layers throughout
arcpy.Merge_management([featureTempConfinedFarms, featureBasinCAFOs],featureTempConfinedFarms+'withCAFOs')
arcpy.CopyFeatures_management(featureTempConfinedFarms+'withCAFOs',featureTempConfinedFarms)

# Assigning value of "kgP_y_rec" and associated N field for CAFO records to "kgP_farm_y" field to match
# up values for calculating radii. They mean the same thing but were named differently
# from the initial data processing
farmLoadFields = ['kgP_y_rec','kgP_farm_y','kgN_y_rec','kgN_farm_y']
up_curs = arcpy.da.UpdateCursor(featureTempConfinedFarms, farmLoadFields)
for row in up_curs:
    if row[1] is None:
        row[1] = row[0]
        row[3] = row[2]
        up_curs.updateRow(row)
del up_curs

#Add Initial Radius Guess; minimum=cell size
arcpy.MakeTableView_management(featureTempConfinedFarms, "ManureClipTableView")
arcpy.TableToTable_conversion("ManureClipTableView", tableManureClip, "ManureClipTable")
tempArray = arcpy.da.TableToNumPyArray(tableManureClip+'\ManureClipTable', ['OBJECTID','kgP_farm_y','AvgR'])
dfManureClip = pd.DataFrame(tempArray)
arcpy.Delete_management(tableManureClip+'/ManureClipTable')
del tempArray
dfManureClip['RInit'] = (pd.to_numeric(dfManureClip['kgP_farm_y']) / (dfManureClip['AvgR'] * (22/7)))**0.5
dfManureClip['Req_Area'] = (22/7) * dfManureClip['RInit'] * dfManureClip['RInit']
dfManureClip.to_csv(tempCSVfile,index=False)
arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempManureClipTable')
# Getting rid of NA Radius and Area fields, so that they may be added in the join
# Also getting rid of kg/farm rates so that they can be joined back as numeric fields
arcpy.DeleteField_management(featureTempConfinedFarms, ['RInit','Req_Area'])
arcpy.JoinField_management(featureTempConfinedFarms,'OBJECTID','tempManureClipTable','OBJECTID', ['RInit', 'Req_Area'])
arcpy.Delete_management('tempManureClipTable') # Deleting temporary table
arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity

#arcpy.AddField_management(featureTempConfinedFarms,fieldInitialRadius,'FLOAT')
#arcpy.AddField_management(featureTempConfinedFarms,fieldAreaRequired,'FLOAT')
#arcpy.CalculateField_management(featureTempConfinedFarms,fieldInitialRadius,'!'+fieldPLoad+'!/!'+fieldAvgRate+'!*(22/7)))^.5','PYTHON_9.3')
#arcpy.CalculateField_management(featureTempConfinedFarms,fieldAreaRequired,'!'+fieldInitialRadius+'!*!'+fieldInitialRadius+'!*(22/7)','PYTHON_9.3')
arcpy.AddField_management(featureTempConfinedFarms,fieldNewRadius,'FLOAT') # Keep this field because it is calculated from UpdateCursor, not a pandas dataframe
#arcpy.AddField_management(featureTempConfinedFarms,fieldAreaDiff,'FLOAT')
arcpy.DeleteField_management(featureTempConfinedFarms,['Join_Count','STATEFP','COUNTYFP','COUNTYNS','NAME','NAMELSAD','LSAD','CLASSFP','MTFCC','CSAFP','CBSAFP','METDIVFP','FUNCSTAT','ALAND','AWATER','INTPTLAT','INTPTLON','F1','Census_Spe','CAFO_Speci','Bin','State','County','Physical_L','Zipcode','City','Operation','Latitude','Longitude','Animal_Num','OcFraction','AvgOfN__as','AvgOfP__as','Recoverabi'])
arcpy.CopyFeatures_management(featureTempConfinedFarms, featureTempConfinedFarms+'clean')

# Removing farms that were placed in areas that should have been excluded from GME, and treating their loads as point sources
# First, selecting those farms that are excluded and making a new layer

# This is currently only working for 1 county. I was having issues getting the BIN_CTY field in the point feature converted to 
# strings, so the "IN" statement of SQL will not work when trying to iterate over a list of multiple values. 
# If this is going to be used again, this needs to be fixed, or at least have the additional counties from 
# pointSourceBinCounties manually added in.
#SQLexpCounties = '"BIN_CTY" IN '+"("+"', '".join(pointSourceBinCountiesFinal)+")"
#SQLexpCounties = 'BIN_CTY = '+str(pointSourceBinCountiesFinal[0])
#
#
#
#
#
#
#arcpy.MakeFeatureLayer_management(featureTempConfinedFarms, 'ConfinedFarmsSelect')
#arcpy.SelectLayerByAttribute_management('ConfinedFarmsSelect', 'NEW_SELECTION', SQLexpCounties)
#arcpy.CopyFeatures_management('ConfinedFarmsSelect', featurePointSourceFarms) # CopyFeatures will copy only those rows selected
## Add in DeleteFeatures_management here - but waiting until verification that SelectLayer works properly, don't want to delete my farm points!
#arcpy.SelectLayerByAttribute_management('ConfinedFarmsSelect', 'CLEAR_SELECTION')
#
#up_curs = arcpy.UpdateCursor(featureTempConfinedFarms, SQLexpCounties) # This could potentially be replaced by DeleteFeatures_management, which acts only on selected rows
#for row in up_curs:
#    if str(row.getValue('BIN_CTY')) in pointSourceBinCounties:
#        up_curs.deleteRow(row)
#
#del up_curs
#
##Convert point source farms to raster. These are added directly into the final calculation
#arcpy.PointToRaster_conversion(featurePointSourceFarms, fieldNLoad, rasterNPointSourceFarms, 'SUM')
#arcpy.PointToRaster_conversion(featurePointSourceFarms, fieldPLoad, rasterPPointSourceFarms, 'SUM')
#
#

## Need to create pasture buffers in order to mask out confined buffers
maskNLCD = arcpy.sa.Con(inRasterNLCD == 81,1,0)

maskNLCDCAFO = arcpy.sa.Con(maskNLCD==1,1,0)
maskNLCDCAFO2 = arcpy.sa.SetNull(maskNLCDCAFO==0,1)
#Run Focal Stats on Pasture Land
neighborhood = arcpy.sa.NbrCircle(paramFocalDistPasture,'CELL')
FocalStatsPast = arcpy.sa.FocalStatistics(maskNLCDCAFO,neighborhood,'SUM','NODATA')
#Calculate Neighborhood Fertilizer Area Raster
FocalAreaPast = FocalStatsPast*cellSize**2
FocalAreaPast.save(rasterFocalAreaPast)

arcpy.RasterToPolygon_conversion(maskNLCDCAFO2,featureNLCDPasture)
arcpy.Clip_analysis(featureNLCDPasture,featureTempAllFertilzedCellsRect,featurePastureCells)
arcpy.SpatialJoin_analysis(featurePastureCells,featureCounties,featurePastureCounties)
arcpy.Dissolve_management(featurePastureCounties,featurePastureGME,fieldCountyJoin,'','MULTI_PART')
arcpy.Copy_management(featurePastureGME,featurePastureGME+'clean')

# Converting the 'Operations' field in the pasture farms table to data type 'long' instead of 'string'
arcpy.TableToTable_conversion(tableFarmCountsPast, pathCalcGDB, "calcfieldTable")
tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', [fieldLoadID, 'Operations'])
dfCalcField = pd.DataFrame(tempArray)
arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
del tempArray
# Input fields to calculate and formula to calculate them
dfCalcField['Operations'] = pd.to_numeric(dfCalcField['Operations'], errors='coerce')
dfCalcField.to_csv(tempCSVfile,index=False)
arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
# Input original table to be joined back to
arcpy.DeleteField_management(tableFarmCountsPast, ['Operations'])
arcpy.JoinField_management(tableFarmCountsPast,fieldLoadID,'tempcalcfieldTable2',fieldLoadID, ['Operations']) # Need to make sure correct fields are being joined!
arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity

#Determine Total Number of Bins
arcpy.Statistics_analysis(tableFarmCountsPast,'tableBinMax',[[fieldAnimalBin,'MAX'],['Operations','SUM']]) # Need to convert operations to long instead of string
rows=arcpy.SearchCursor('tableBinMax')
for row in rows:
    binIDmax=row.getValue('MAX_GMEID')
    TotalEstAnimals=row.getValue('SUM_Operations')

#loop Through Each Bin type and distribute to available cells based on availability of Ag Cells near by.
#This loop opens up GME once per iteration. Make sure that you have the correct version of Arc installed to run GME;
#as of 7/3/2017, GME cannot run on versions of Arc past 10.3.
start = time.ctime()
startsec = time.time()
for binID in range(1,int(binIDmax+1)):
    arcpy.MakeTableView_management(tableFarmCountsPast,CurrentBin,fieldAnimalBin+'='+str(binID))
    time.sleep(2)
    arcpy.JoinField_management(featurePastureGME,fieldCountyJoin,CurrentBin,fieldCountyJoin)
    # Removing Null rows
    up_curs = arcpy.UpdateCursor(featurePastureGME, "BIN_CTY IS NULL")
    for row in up_curs:
        if not row.getValue('BIN_CTY'):
            up_curs.deleteRow(row)

    del up_curs
    
    # Input correct table
    arcpy.MakeTableView_management(featurePastureGME, "calcfieldTableView")
    arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
    tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', ['*'])
    dfCalcField = pd.DataFrame(tempArray)
    arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
    del tempArray
    # Input fields to calculate and formula to calculate them
    dfCalcField[fieldAreaRequired] = pd.to_numeric(dfCalcField[fieldPLoad]) / paramPastureAssimiliation
    dfCalcField.to_csv(tempCSVfile,index=False)
    arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
    # Input original table to be joined back to
    arcpy.JoinField_management(featurePastureGME,fieldCountyJoin,'tempcalcfieldTable2',fieldCountyJoin, [fieldAreaRequired]) # Need to make sure correct fields are being joined!
    arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
    arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
    del dfCalcField
    
    arcpy.PolygonToRaster_conversion(featurePastureGME,fieldAreaRequired,rasterRequiredAreaPast)
    inRasterRequiredArea = arcpy.Raster(rasterRequiredAreaPast)
    inRasterFocalArea = arcpy.Raster(rasterFocalAreaPast)
    conRequiredArea = arcpy.sa.Con((inRasterRequiredArea>inRasterFocalArea),1,0)
    ExclusionResult = arcpy.GetRasterProperties_management(conRequiredArea,'MAXIMUM')
    ExclusionResultMax = ExclusionResult.getOutput(0)
    if int(ExclusionResultMax) == 0:
        for fifthmult in range(0,5):
            mult = 45*fifthmult
            arcpy.MakeFeatureLayer_management(featurePastureGME,'PastureClipOneFifth')
            arcpy.SelectLayerByAttribute_management('PastureClipOneFifth', 'NEW_SELECTION', ' "OBJECTID" >= '+str(1+mult)+' AND "OBJECTID" <= '+str(45+mult))
            arcpy.CopyFeatures_management('PastureClipOneFifth', 'PastureClipOneFifthGME')
            # Error window popping up in GME is preventing loop from continuing. Can't figure out how to stop it,
            # so using this unnecessarily convoluted method to get around it.
            # Using threading to start GME, then run a separate Python script that presses the "enter" key after 5 seconds
            os.chdir("S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python")
            thread1 = threading.Thread(target=RunGMEPast_NoExcl)
            thread2 = threading.Thread(target=RunEnterKey)
            thread1.start()
            thread2.start()
            thread1.join() # Stops python until thread closes, signaling the finish of GME
    else:
        nullRequiredArea = arcpy.sa.SetNull(conRequiredArea==0,1)
        arcpy.RasterToPolygon_conversion(nullRequiredArea,featureExclusionArea) #This resets the python working directory!!! Need to reassign it
#        os.chdir("S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python")
#        # Some counties do not have any usable Ag cells after looking at excluded area - for these counties, ignore exclusion area
#        # and place farms down anyway. These farms need to be treated as point sources!
#        arcpy.SpatialJoin_analysis(featureExclusionArea, featureCounties, featureExclusionAreaCounties,'JOIN_ONE_TO_MANY','','','INTERSECT')
#        arcpy.Dissolve_management(featureExclusionAreaCounties, featureExclusionAreaCountiesDiss, fieldCountyJoin,'','MULTI_PART')
##        arcpy.JoinField_management(featureExclusionAreaCountiesDiss, fieldCountyJoin, featureTempCountyManureClip, fieldCountyJoin, ['Req_Area'])
#        arcpy.RasterToPolygon_conversion(conRequiredArea, 'RequiredAreaPolygon', 'SIMPLIFY','Value')
#        arcpy.SpatialJoin_analysis('RequiredAreaPolygon', featureCounties, 'RequiredAreaPolygonCounties','JOIN_ONE_TO_MANY','','','INTERSECT')
#        arcpy.Dissolve_management('RequiredAreaPolygonCounties', 'RequiredAreaPolygonCounties_Diss', fieldCountyJoin,'gridcode MIN','MULTI_PART')
##        arcpy.Statistics_analysis('RequiredAreaPolygonCounties_Diss', 'tableRequiredArea_Stats', ['value', 'MIN'], [fieldCountyJoin])
#        arcpy.JoinField_management(featureExclusionAreaCountiesDiss, fieldCountyJoin, 'RequiredAreaPolygonCounties_Diss', fieldCountyJoin)
#        up_curs = arcpy.UpdateCursor(featureExclusionAreaCountiesDiss, "MIN_gridcode = 1")
#        for row in up_curs:
#            if int(row.getValue('MIN_gridcode')) == 1:
#                up_curs.deleteRow(row)
#
#        del up_curs
#        arcpy.CopyFeatures_management(featureExclusionAreaCountiesDiss, featureExclusionArea)
        for fifthmult in range(0,5):
            mult = 45*fifthmult
            arcpy.MakeFeatureLayer_management(featurePastureGME,'PastureClipOneFifth')
            arcpy.SelectLayerByAttribute_management('PastureClipOneFifth', 'NEW_SELECTION', ' "OBJECTID" >= '+str(1+mult)+' AND "OBJECTID" <= '+str(45+mult))
            arcpy.CopyFeatures_management('PastureClipOneFifth', 'PastureClipOneFifthGME')
            os.chdir("S:\\Users\\roushjac\\Tipping Points\\Manure\\Script\\Python")
            thread1 = threading.Thread(target=RunGMEPast_Excl)
            thread2 = threading.Thread(target=RunEnterKey)
            thread1.start()
            thread2.start()
            thread1.join() # Stops python until thread closes, signaling the finish of GME
#            del(nullRequiredArea)
#            arcpy.Delete_management(featureExclusionArea)
#            arcpy.Delete_management(featureExclusionAreaCounties)
#            arcpy.Delete_management(featureExclusionAreaCountiesDiss)
        
    print 'The bin is:',binID
    currenttime = time.time()
    print 'Loop has been running for '+str(currenttime - startsec)+' seconds, or '+str((currenttime - startsec)/60)+' minutes.'
    arcpy.CopyFeatures_management(featurePastureGME+'clean',featurePastureGME)
    del(inRasterRequiredArea, inRasterFocalArea, conRequiredArea)

end = time.ctime()
endsec = time.time()
print 'Start: '+start
print 'End: '+end
print 'Loop took '+str(endsec - startsec)+' seconds, or '+str((endsec - startsec)/60)+' minutes!'

#Join Loads to Pasture Herds
arcpy.JoinField_management(featurePastureHerds,fieldLoadID,tableFarmCountsPast,fieldLoadID)
#arcpy.AddField_management(featurePastureHerds,fieldInitialRadius)
#arcpy.CalculateField_management(featurePastureHerds,fieldInitialRadius,'(['+fieldPLoad+']/('+str(paramPastureAssimiliation)+'))^.5','VB')
# Input correct table
arcpy.MakeTableView_management(featurePastureHerds, "calcfieldTableView")
arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', ['*'])
dfCalcField = pd.DataFrame(tempArray)
arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
del tempArray
# Input fields to calculate and formula to calculate them
dfCalcField[fieldInitialRadius] = (dfCalcField[fieldPLoad] / paramPastureAssimiliation)**.5
dfCalcField.to_csv(tempCSVfile,index=False)
arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
# Input original table to be joined back to
arcpy.JoinField_management(featurePastureHerds,fieldCountyJoin,'tempcalcfieldTable2',fieldCountyJoin, [fieldInitialRadius]) # Need to make sure correct fields are being joined!
arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
del dfCalcField

arcpy.Buffer_analysis(featurePastureHerds, featureWasteBuffers,fieldInitialRadius,'','ROUND','NONE')
#Dissolve Overlapping Buffers
arcpy.Near_analysis(featureWasteBuffers,featureWasteBuffers,0)
arcpy.MakeFeatureLayer_management(featureWasteBuffers,'Near_Buffers')
arcpy.SelectLayerByAttribute_management('Near_Buffers','NEW_SELECTION',' "NEAR_DIST" = 0')
arcpy.Dissolve_management('Near_Buffers',featureWasteBuffersPreDissolved,'','','SINGLE_PART')
arcpy.MakeFeatureLayer_management(featureWasteBuffersPreDissolved,'Diss_Near_Buffers')
arcpy.SelectLayerByLocation_management('Near_Buffers','INTERSECT','Diss_Near_Buffers',0,'NEW_SELECTION')
arcpy.DeleteFeatures_management('Near_Buffers')
arcpy.Merge_management(['Near_Buffers','Diss_Near_Buffers'],featureWasteBuffersDissolved)
arcpy.DeleteField_management(featureWasteBuffersDissolved,['COUNTY','Join_Count','TARGET_FID','JOIN_FID','GMEID','PNTID','CtyID','CTYID','COUNTY_NAM','YEAR','STATE_AVER','MAN_M2','CTYID_1','CTYID_12','CTYN_KGPY','CTYP_KGYR','AvgR','RInit','Req_Area','BIN_CTY','GMEID_1','CTYID_12_13','N_KGYEAR','P_KGYEAR','BIN_CTY_1','N_UNREC','P_UNREC','RNew','ADiff','BUFF_DIST','NEAR_FID','NEAR_FID_1','NEAR_DIST'])
#Clip Buffer by Ag Cells
arcpy.Clip_analysis(featureWasteBuffersDissolved,featurePastureCells,featureWasteBuffersClip)
arcpy.CalculateAreas_stats(featureWasteBuffersClip,featureWasteBuffersClipArea)
arcpy.Intersect_analysis([featureWasteBuffersClipArea,featurePastureHerds],featureWasteBuffersClip,'ONLY_FID')
arcpy.JoinField_management(featureWasteBuffersClipArea,fieldFIDFarm,featureWasteBuffersClip,'FID_'+featureWasteBuffersClipArea)
arcpy.JoinField_management(featureWasteBuffersClipArea,'FID_'+featurePastureHerds,featurePastureHerds,fieldFIDFarm)

#Calculate Dissolved Area Total and Dissolved Area Ag Land and Join to original Points
statsFields = [[fieldNLoad,'SUM'],[fieldPLoad,'SUM']]
arcpy.Statistics_analysis(featureWasteBuffersClipArea,tableGroupedBuffers,statsFields,'FID_'+featureWasteBuffersClipArea)
arcpy.JoinField_management(featureWasteBuffersClipArea,'FID_'+featureWasteBuffersClipArea,tableGroupedBuffers,'FID_'+featureWasteBuffersClipArea)

#Calculate Average Rate over Combined Pasture Area
#arcpy.CalculateField_management(featureWasteBuffersClipArea,fieldNLoad,'['+'SUM_'+fieldNLoad+']/[F_AREA]')
#arcpy.CalculateField_management(featureWasteBuffersClipArea,fieldPLoad,'['+'SUM_'+fieldPLoad+']/[F_AREA]')
# Input correct table
arcpy.MakeTableView_management(featureWasteBuffersClipArea, "calcfieldTableView")
arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', ['OBJECTID',fieldNLoadSum, fieldPLoadSum, 'F_AREA',fieldNLoad,fieldPLoad])
dfCalcField = pd.DataFrame(tempArray)
arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
del tempArray
# Input fields to calculate and formula to calculate them
dfCalcField[fieldNLoad] = dfCalcField['SUM_'+fieldNLoad] / dfCalcField['F_AREA']
dfCalcField[fieldPLoad] = dfCalcField['SUM_'+fieldPLoad] / dfCalcField['F_AREA']
dfCalcField.to_csv(tempCSVfile,index=False)
arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
# Input original table to be joined back to
arcpy.JoinField_management(featureWasteBuffersClipArea,'OBJECTID','tempcalcfieldTable2','OBJECTID', [fieldNLoad, fieldPLoad]) # Need to make sure correct fields are being joined!
arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
del dfCalcField


#Convert Pasture to Raster
arcpy.PolygonToRaster_conversion(featureWasteBuffersClipArea,fieldNLoad,rasterNPastureRate)
arcpy.PolygonToRaster_conversion(featureWasteBuffersClipArea,fieldPLoad,rasterPPastureRate)

##Convert Pasture to Raster
##arcpy.PointToRaster_conversion(featurePastureHerds,fieldNLoad,rasterNPasture,'SUM')
##arcpy.PointToRaster_conversion(featurePastureHerds,fieldPLoad,rasterPPasture,'SUM')

#Finalizing pasture rasters
#Convert null values to 0 and Add All Contributions
inRasterPastureNRate = arcpy.Raster(rasterNPastureRate)
#inRasterPastureN = inRasterPastureNRate*cellSize*cellSize
#RasterPastureNnull = arcpy.sa.IsNull(inRasterPastureN)
RasterPastureNnoNull = arcpy.sa.Con(arcpy.sa.IsNull(inRasterPastureNRate),0,inRasterPastureNRate)
RasterPastureNnoNull.save('RasterPastureNnoNull')
del(inRasterPastureNRate,RasterPastureNnoNull)

inRasterPasturePRate = arcpy.Raster(rasterPPastureRate)
#inRasterPastureP = inRasterPasturePRate*cellSize*cellSize
#RasterPasturePnull = arcpy.sa.IsNull(inRasterPastureP)
RasterPasturePnoNull = arcpy.sa.Con(arcpy.sa.IsNull(inRasterPasturePRate),0,inRasterPasturePRate)
RasterPasturePnoNull.save('RasterPasturePnoNull')
del(inRasterPasturePRate,RasterPasturePnoNull)

## Copying pasture buffers to another layer to preserve them - using similar names for the confined
## farms buffers
arcpy.CopyFeatures_management(featureWasteBuffersClipArea, featureWasteBuffersClipPast)

# Don't want to spread confined manure owhere there is already pasture manure
arcpy.Erase_analysis(featureTempCAFOFertilizedCells,featureWasteBuffersClipPast, featureTempCAFOFertilizedCellsNoPast+'prelim')
# Adding true CAFO locations back into total Ag area to make sure every point can be matched to a buffer
arcpy.Merge_management([featureTempCAFOFertilizedCellsNoPast+'prelim',featureCAFOLocationPolys], featureTempCAFOFertilizedCellsNoPast)


#%% Resetting ConfinedFarms in case buffer process does not work properly
arcpy.CopyFeatures_management(featureTempConfinedFarms+'clean', featureTempConfinedFarms)


#%%
# Create buffer around each farm to spread manure. If there is not enough area in the buffers, iteratively increase 
# the buffer radius until 96% of confined farms meet their required area

Conv = 1
iteration = 0
start = time.ctime()
startsec = time.time()
while Conv>ConvThreshold: # Had to stop this loop at 0.03 Conv after it ran over the weekend. Don't know if it ever would have finished!
    startlooptime = time.time()
    print 'This iteration started:',time.ctime()
    #Buffer CAFO Locations
#    arcpy.Buffer_analysis(featureTempConfinedFarms, featureWasteBuffers,fieldInitialRadius,'','ROUND','NONE')

    arcpy.Buffer_analysis(in_features="ConfinedFarms",out_feature_class="D:/Arc_Data/ManureOutputs.gdb/Waste_Buff_New",buffer_distance_or_field="RInit",line_side="FULL",line_end_type="ROUND",dissolve_option="NONE",dissolve_field="#")
    #Dissolve Overlapping Buffers
    arcpy.Near_analysis(featureWasteBuffers,featureWasteBuffers,0)
    arcpy.MakeFeatureLayer_management(featureWasteBuffers,'Near_Buffers')
    arcpy.SelectLayerByAttribute_management('Near_Buffers','NEW_SELECTION',' "NEAR_DIST" = 0')
    arcpy.Dissolve_management('Near_Buffers',featureWasteBuffersPreDissolved,'','','SINGLE_PART') # This was freezing after a few iterations when it was set to "SINGLE_PART" because of memory issues. Changing to "MULTI_PART"

#   ? call the seperate subprocess function  
#    dissolveInSubprocess(in_fc = 'Near_Buffers', out_fc = featureWasteBuffersPreDissolved, dissolve_fields = '#', stat_fields ='#', multi_part = 'MULTI_PART', unsplit_lines = "DISSOLVE_LINES", xytol = '#')
#    dissolveInSubprocess()
    
    arcpy.SimplifyPolygon_cartography(featureWasteBuffersPreDissolved,featureWasteBuffersPreDissolved+'Simp','POINT_REMOVE',30,'','','')
#    arcpy.AddField_management(featureWasteBuffersPreDissolved+'Simp','Diss')
#    arcpy.CalculateField_management(featureWasteBuffersPreDissolved+'Simp','Diss',1,'VB')
    # Input correct table
    arcpy.MakeTableView_management(featureWasteBuffersPreDissolved+'Simp', "calcfieldTableView")
    arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
    tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', ['*'])
    dfCalcField = pd.DataFrame(tempArray)
    arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
    del tempArray
    # Input fields to calculate and formula to calculate them
    dfCalcField['Diss'] = 1
    dfCalcField.to_csv(tempCSVfile,index=False)
    arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
    # Input original table to be joined back to
    arcpy.JoinField_management(featureWasteBuffersPreDissolved+'Simp','OBJECTID','tempcalcfieldTable2','OBJECTID', ['Diss']) # Need to make sure correct fields are being joined!
    arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
    arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity

    arcpy.Dissolve_management(featureWasteBuffersPreDissolved+'Simp',featureWasteBuffersPreDissolved+'2',['Diss'],'','MULTI_PART')
    arcpy.MultipartToSinglepart_management(featureWasteBuffersPreDissolved+'2',featureWasteBuffersPreDissolved)
    arcpy.MakeFeatureLayer_management(featureWasteBuffersPreDissolved,'Diss_Near_Buffers')
    arcpy.SelectLayerByLocation_management('Near_Buffers','INTERSECT','Diss_Near_Buffers',0,'NEW_SELECTION')
    arcpy.DeleteFeatures_management('Near_Buffers')
    arcpy.Merge_management(['Near_Buffers','Diss_Near_Buffers'],featureWasteBuffersDissolved) # I think this is a layer of (actual buffers) + (simplified buffers)?
    arcpy.DeleteField_management(featureWasteBuffersDissolved,['COUNTY','Join_Count','TARGET_FID','JOIN_FID','GMEID','PNTID','CtyID','CTYID','COUNTY_NAM','YEAR','STATE_AVER','MAN_M2','CTYID_1','CTYID_12','CTYN_KGPY','CTYP_KGYR','AvgR','RInit','Req_Area','BIN_CTY','GMEID_1','CTYID_12_13','N_KGYEAR','P_KGYEAR','BIN_CTY_1','N_UNREC','P_UNREC','RNew','ADiff','BUFF_DIST','NEAR_FID','NEAR_FID_1','NEAR_DIST'])

    #Clip Buffer by Ag cells and Pasture buffers - do not want to spread confined farms in pasture buffers
    arcpy.Clip_analysis(featureWasteBuffersDissolved,featureTempCAFOFertilizedCellsNoPast,featureWasteBuffersClip)

    # CalculateAreas is not working on Hydroiliad with Arc 10.2.2 as of 7/20. Proceed with caution
#    arcpy.CalculateAreas_stats(featureWasteBuffersClip,featureWasteBuffersClipArea) #This calculates area taken up by clipped Ag buffers
    # Repacing CalculateArea with a copy of Shape_Area created with the clip - but don't want to directly use the field since we cannot delete it later (it is a required field)
    arcpy.AddField_management(featureWasteBuffersClip, fieldClipArea, 'DOUBLE')
    up_curs = arcpy.da.UpdateCursor(featureWasteBuffersClip, ['Shape_Area',fieldClipArea])
    for row in up_curs:
        row[1] = row[0]
        up_curs.updateRow(row)
    del up_curs
    arcpy.Near_analysis(featureTempConfinedFarms,featureWasteBuffersClip,0) # I think this function also creates a field, nearFID, that gives a unique value to each polygon
    arcpy.JoinField_management(featureTempConfinedFarms,fieldFIDGroup,featureWasteBuffersClip,fieldFIDFarm, [fieldClipArea])
    #Change Shape_Area field from CAFOs into F_AREA field to keep names consistent
    areaFields = [fieldClipArea,'Shape_Area']
    up_curs = arcpy.da.UpdateCursor(featureWasteBuffersClip, areaFields)
    for row in up_curs:
        if row[0] is None:
            row[0] = row[1]
            up_curs.updateRow(row)
    del up_curs
    #Remove Unecessary Fields
    arcpy.DeleteField_management(featureTempConfinedFarms,['Near_Dist'])
    #Calculate Dissolved Area Total and Dissolved Area Ag Land and Join to original Points
    statsFields = [[fieldAreaRequired, 'SUM'],[fieldNLoad,'SUM'],[fieldPLoad,'SUM']]
    arcpy.Statistics_analysis(featureTempConfinedFarms,tableGroupedBuffers,statsFields,fieldFIDGroup)
    arcpy.JoinField_management(featureTempConfinedFarms,fieldFIDGroup,tableGroupedBuffers,fieldFIDGroup)

    #Calculate Area Percent Difference and Update Buffer Radius

#    arcpy.CalculateField_management(featureTempConfinedFarms,fieldAreaDiff,'min((!'+fieldAreaReqTotal+'!-!'+fieldClipArea+'!)/!'+fieldClipArea+'!,50)','PYTHON')
    # Input correct table
#    arcpy.MakeTableView_management(featureTempConfinedFarms, "calcfieldTableView")
#    arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
#    tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', ['*'])
#    dfCalcField = pd.DataFrame(tempArray)
#    arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
#    del tempArray
#    # Input fields to calculate and formula to calculate them
#    dfCalcField[fieldAreaDiff] = min([(dfCalcField[fieldAreaReqTotal]-dfCalcField[fieldClipArea])/dfCalcField[fieldClipArea]],50) # Using 50 as a min to simplify if the % diff between clipped and req'd area is too big
#    dfCalcField.to_csv(tempCSVfile,index=False)
#    arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
#    # Input original table to be joined back to
#    arcpy.JoinField_management(featureTempConfinedFarms,fieldFIDGroup,'tempcalcfieldTable2',fieldFIDGroup, [fieldAreaDiff]) # Need to make sure correct fields are being joined!
#    arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
#    arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
#    del dfCalcField

    arcpy.MakeTableView_management(featureTempConfinedFarms, "calcfieldTableView")
    arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
    tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', [fieldAreaReqTotal, fieldClipArea, fieldFIDGroup])
    dfCalcField = pd.DataFrame(tempArray)
    arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
    del tempArray
    # Input fields to calculate and formula to calculate them
    dfCalcField[fieldAreaDiff] = (dfCalcField[fieldAreaReqTotal]-dfCalcField[fieldClipArea])/dfCalcField[fieldClipArea] # Using 40 as a min to simplify if the % diff between clipped and req'd area is too big
    dfCalcField.loc[(dfCalcField['ADiff'] > 40),'ADiff'] = 40
    dfCalcField.loc[(dfCalcField['ADiff'] < 0),'ADiff'] = 0
    print "Avg ADiff: ",dfCalcField.mean()['ADiff']
    dfCalcField.to_csv(tempCSVfile,index=False)
    arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
    # Input original table to be joined back to
    arcpy.JoinField_management(featureTempConfinedFarms,fieldFIDGroup,'tempcalcfieldTable2',fieldFIDGroup, [fieldAreaDiff]) # Need to make sure correct fields are being joined!
    arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
    arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
    

    # If a farm takes up an area smaller than the cell, label it as converged
    problemFarmFields = [fieldAreaRequired, fieldAreaDiff]
    up_curs = arcpy.da.UpdateCursor(featureTempConfinedFarms, problemFarmFields)
    for row in up_curs:
        if row[0] < ((int(cellSize)/2)*(int(cellSize)/2)):
            row[1] = 0
            up_curs.updateRow(row)
    del up_curs


    #Determine which CAFOs have not converged
    arcpy.MakeTableView_management(featureTempConfinedFarms,BuffersNotConverged,'abs('+fieldAreaDiff+')>'+str(ReqAreaThreshold))
    #Count the number of CAFOs that have no converged
    countConv = arcpy.GetCount_management(BuffersNotConverged)
    iteration=iteration+1
    print 'Not converged count=', countConv,', iteration =',iteration
    #Count total CAFOs
    countTotal = arcpy.GetCount_management(featureTempConfinedFarms)
    Conv = float(str(countConv))/float(str(countTotal))
    print 'Conv:', Conv
    #Update Initial Guess.  Dampen magnitude of update based on the number CAFOs that have converged.
    #Thinking the best way to do this is by using UpdateCursor, since it is easy to specify conditions - alternatives would be using pandas dataframes or CalculateField (if it works on your machine)
#    arcpy.CalculateField_management(featureTempConfinedFarms,fieldNewRadius,'((['+fieldAreaDiff+'])+1)^.5*['+fieldInitialRadius+']','VB')
#    # Input correct table
#    arcpy.MakeTableView_management(featureTempConfinedFarms, "calcfieldTableView")
#    arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
#    tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', ['*'])
#    dfCalcField = pd.DataFrame(tempArray)
#    arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
#    del tempArray
#    # Input fields to calculate and formula to calculate them
#    dfCalcField[fieldNewRadius] = ((dfCalcField[fieldAreaDiff] + 1)**.5)*dfCalcField[fieldInitialRadius]
#    dfCalcField.to_csv(tempCSVfile,index=False)
#    arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
#    # Input original table to be joined back to
#    arcpy.JoinField_management(featureTempConfinedFarms,fieldCountyJoin,'tempcalcfieldTable2',fieldCountyJoin, [fieldAreaDiff]) # Need to make sure correct fields are being joined!
#    arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
#    arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
#    del dfCalcField
    
    if Conv>.1:
#        arcpy.CalculateField_management(BuffersNotConverged,fieldNewRadius,'((['+fieldAreaDiff+'])+1)^.5*['+fieldInitialRadius+']','VB')
        convFields = [fieldNewRadius, fieldAreaDiff, fieldInitialRadius]
        up_curs = arcpy.da.UpdateCursor(featureTempConfinedFarms, convFields)
        for row in up_curs:
            if row[1] > ReqAreaThreshold:
                row[0] = (((row[1])+1)**0.5)*row[2]
                up_curs.updateRow(row)
        del up_curs
    elif (Conv<.1 and Conv>.05):
#        arcpy.CalculateField_management(BuffersNotConverged,fieldNewRadius,'((.75*['+fieldAreaDiff+'])+1)^.5*['+fieldInitialRadius+']','VB')
        convFields = [fieldNewRadius, fieldAreaDiff, fieldInitialRadius]
        up_curs = arcpy.da.UpdateCursor(featureTempConfinedFarms, convFields)
        for row in up_curs:
            if row[1] > ReqAreaThreshold:
                row[0] = (((0.75*row[1])+1)**0.5)*row[2]
                up_curs.updateRow(row)
        del up_curs
    elif (Conv<.05 and Conv>.02):
#        arcpy.CalculateField_management(BuffersNotConverged,fieldNewRadius,'((.5*['+fieldAreaDiff+'])+1)^.5*['+fieldInitialRadius+']','VB')
        convFields = [fieldNewRadius, fieldAreaDiff, fieldInitialRadius]
        up_curs = arcpy.da.UpdateCursor(featureTempConfinedFarms, convFields)
        for row in up_curs:
            if row[1] > ReqAreaThreshold:
                row[0] = (((0.5*row[1])+1)**0.5)*row[2]
                up_curs.updateRow(row)
        del up_curs
    else:
#        arcpy.CalculateField_management(BuffersNotConverged,fieldNewRadius,'((.1*['+fieldAreaDiff+'])+1)^.5*['+fieldInitialRadius+']','VB')
        convFields = [fieldNewRadius, fieldAreaDiff, fieldInitialRadius]
        up_curs = arcpy.da.UpdateCursor(featureTempConfinedFarms, convFields)
        for row in up_curs:
            if row[1] > ReqAreaThreshold:
                row[0] = (((0.1*row[1])+1)**0.5)*row[2]
                up_curs.updateRow(row)
        del up_curs

    #Export preliminary output.  This can be ignored if when not debugging code
#    arcpy.CopyFeatures_management(featureTempConfinedFarms,'FarmsPrelim')
#    arcpy.CopyFeatures_management(featureWasteBuffersPreDissolved,'PreFarmsDissPrelim')
#    arcpy.CopyFeatures_management(featureWasteBuffersClipArea,'FarmsClipPrelim')

    #Update initial guess radius to new radius
#    arcpy.CalculateField_management(featureTempConfinedFarms,fieldInitialRadius,'['+fieldNewRadius+']','VB')
    # Input correct table
    arcpy.MakeTableView_management(featureTempConfinedFarms, "calcfieldTableView")
    arcpy.TableToTable_conversion("calcfieldTableView", pathCalcGDB, "calcfieldTable")
    tempArray = arcpy.da.TableToNumPyArray(pathCalcGDB+'/calcfieldTable', [fieldInitialRadius, fieldNewRadius, fieldFIDGroup])
    dfCalcField = pd.DataFrame(tempArray)
    arcpy.Delete_management(pathCalcGDB+'/calcfieldTable')
    del tempArray
    # Input fields to calculate and formula to calculate them
    dfCalcField.loc[pd.notnull(dfCalcField.RNew),'RInit'] = dfCalcField.loc[pd.notnull(dfCalcField.RNew),'RNew']
#    dfCalcField.dropna(how='any').loc[:,fieldInitialRadius] = dfCalcField.dropna(how='any').loc[:,fieldNewRadius]
    dfCalcField.to_csv(tempCSVfile,index=True)
    arcpy.TableToTable_conversion(tempCSVfile,outDir,'tempcalcfieldTable2')
    # Input original table to be joined back to and correct field name
    arcpy.DeleteField_management(featureTempConfinedFarms,[fieldInitialRadius])
    arcpy.JoinField_management(featureTempConfinedFarms,fieldFIDGroup,'tempcalcfieldTable2',fieldFIDGroup, [fieldInitialRadius]) # Need to make sure correct fields are being joined!
    arcpy.Delete_management('tempcalcfieldTable2') # Deleting temporary table
    arcpy.Delete_management(tempCSVfile) # Also deleting csv file - want to reuse the same filename for simplicity
    del dfCalcField

    #Delete Uneeded Fields and Files
#    fields = arcpy.ListFields(featureTempConfinedFarms)
#    for field in fields:
#        if str(field.baseName) == 'Shape_Area':
#            print field.baseName
#            field.required = False
    arcpy.DeleteField_management(featureTempConfinedFarms,[fieldClipArea,fieldAreaReqTotal,'FREQUENCY',fieldAreaDiff, 'NEAR_FID'])
#    arcpy.Delete_management(featureWasteBuffers) # Think these Delete_management functions are freezing the script for some reason
#    arcpy.Delete_management(featureWasteBuffersPreDissolved)
#    arcpy.Delete_management(featureWasteBuffersDissolved)
#    arcpy.Delete_management(featureWasteBuffersClip)
#    arcpy.Delete_management(featureWasteBuffersPreDissolved+'2')
#    arcpy.Delete_management(featureWasteBuffersPreDissolved+'Simp')
    #Keep these fields if the loop is complete
    if Conv > ConvThreshold:
        arcpy.DeleteField_management(featureTempConfinedFarms,[fieldNLoadSum,fieldPLoadSum,fieldFIDGroup,fieldFIDGroup+'_1'])
#        arcpy.Delete_management(featureWasteBuffersClipArea)
    endlooptime = time.time()
    print 'This iteration took '+str(endlooptime - startlooptime)+' seconds, '+str((endlooptime - startlooptime)/60.)+' minutes, or '+str((endlooptime - startlooptime)/3600.)+' hours.'
print 'Buffer area has converged #winning'
end = time.ctime()
endsec = time.time()
print 'Start: '+start
print 'End: '+end
print 'Total time was '+str(endsec - startsec)+' seconds, '+str((endsec - startsec)/60)+' minutes, or '+str((endsec - startsec)/3600)+' hours!'

#%%

#Join points to dissolved buffers
arcpy.JoinField_management(featureWasteBuffersClip,fieldFIDFarm,tableGroupedBuffers,fieldFIDGroup)

#Output CAFO polys for Use in Commercial Fertilizer Script
arcpy.Copy_management(featureWasteBuffersClip,outCAFOArea)


#Apply Unrecovered Loads to Points
arcpy.PointToRaster_conversion(featureTempConfinedFarms,fieldNUnrecovered,rasterNConfUnrec,'SUM')
arcpy.PointToRaster_conversion(featureTempConfinedFarms,fieldPUnrecovered,rasterPConfUnrec,'SUM')


#Finalizing unrecovered load rasters
inRasterNUnrec = arcpy.Raster(rasterNConfUnrec)
inRasterPUnrec = arcpy.Raster(rasterPConfUnrec)
#RasterUnrecNnull = arcpy.sa.IsNull(inRasterNUnrec)
RasterUnrecNnoNull = arcpy.sa.Con(arcpy.sa.IsNull(inRasterNUnrec),0,inRasterNUnrec)
#RasterUnrecPnull = arcpy.sa.IsNull(inRasterPUnrec)
RasterUnrecPnoNull = arcpy.sa.Con(arcpy.sa.IsNull(inRasterPUnrec),0,inRasterPUnrec)
RasterUnrecNnoNull.save('RasterUnrecNnoNull')
RasterUnrecPnoNull.save('RasterUnrecPnoNull')

#Finalizing point source farms raster
#inRasterNPointSource = arcpy.Raster(rasterNPointSourceFarms)
#inRasterPPointSource = arcpy.Raster(rasterPPointSourceFarms)
#RasterPointSourceNnoNull = arcpy.sa.Con(arcpy.sa.IsNull(inRasterNPointSource),0,inRasterNPointSource)
#RasterPointSourcePnoNull = arcpy.sa.Con(arcpy.sa.IsNull(inRasterPPointSource),0,inRasterPPointSource)
#RasterPointSourceNnoNull.save('RasterPointSourceNnoNull')
#RasterPointSourcePnoNull.save('RasterPointSourcePnoNull')
#
#RasterPointSourceNnoNull = arcpy.Raster('RasterPointSourceNnoNull')
#RasterPointSourcePnoNull = arcpy.Raster('RasterPointSourcePnoNull')


### Confined farm loads are not calculated here - buffer polygons are passed to a seperate
### script




# As of 7/18/2017, we have rasters for all inputs except confined farms. These need to be debiased using the new method before
# the correct raster can be generated

NManureTotal = RasterPastureNnoNull + RasterUnrecNnoNull + RasterNManurenoNull
PManureTotal = RasterPasturePnoNull + RasterUnrecPnoNull + RasterPManurenoNull